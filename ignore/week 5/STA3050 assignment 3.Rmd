---
title: "STA3050-Assignment 3"
author: "Chesia Anyika"
date: "2024-06-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries

```{r}
library(tidyverse)
```

# Question

A manager of a national park collected data on the number of visitors (in thousands) who visited the park in each quarter of 2021 and 2022. The data includes:

| Season  | Seasonal Index | 2021 | 2022 |
|---------|----------------|------|------|
| Summer  | 162            | 51   | 54   |
| Monsoon | 62             | 28   | 32   |
| Winter  | 87             | 41   | 45   |
| Spring  | 89             | 36   | 43   |

Tasks:

1\. Calculate the deseasonalized values for each quarter.

2\. Compute the trend values for the deseasonalized data.

3\. Plot the quarterly number of visitors for 2021 and 2022, along with the deseasonalized

values and trend values on the same graph.

## 1. Calculate the de-seasonalised values for each quarter.

First I created the table in r, in long format:

```{r}
#create vectors
year <- c(rep(2021, 4), rep(2022, 4))
Season <- rep(c('Summer', 'Monsoon', 'Winter', 'Spring'),2)
Value <- c(51, 28, 41, 36,54, 32, 45, 43)
Index <- rep(c(162, 62, 87, 89), 2)

#create dataframe
S.data <- data.frame(year, Season, Value, Index)

#View table
S.data
```

For calculating de-seasonalized values, we divide the actual value by its corresponding seasonal index as per the formula:

$$
\text{D.V} = \frac{\text{Actual Value}}{\text{Seasonal Index}}\times 100
$$

I computed this as follows and added the results to a new column in the data-frame:

```{r}
#compute deseasonalised values
S.data$D.V <- (S.data$Value/S.data$Index)*100

#view results
S.data$D.V
```

## 2. Compute the trend values for each quarter

We now determine the trend by **fitting a linear trend line by the method of least square**.

Here, time is in the form of seasons (Summer, Monsoon, Winter, Spring) which is non-numeric. Therefore, we use the sequential numbering system and take 𝑡 = 1,2,3, ... instead of the name of seasons as shown below:

```{r}
#create numeric time column
S.data$t <- seq(1,8)

#view result
S.data$t
```

The linear trend line equation is given by:

$$
Y_{t} = \beta_{0} + \beta_{1}t
$$

For ease of computation, we can transform $t$ to be in terms of $X_{t}$, as per the formula:

$$
X_t =
\begin{cases}
\frac{t - middle\ value}{interval \ in \ t \ values} & \text{when n is odd}\\
\frac{t - average\ of\ two \ middle\ values}{half\ of \ interval \ in \ t \ values} & \text{when n is even}
\end{cases}
$$

Since $n = 8$ is even, the formula for $X_{t}$ is:

$$
X_{t} = \frac{t - \text{average of two middle values}}{\text{half of interval in t values}}
$$

I computed this as follows:

```{r}
#define formula for computing Xt
compute_Xt <- function(t) {
  n <- length(t)
  interval <- diff(range(t)) / (n - 1)
  
  if (n %% 2 == 1) {
    middle_value <- median(t)
    X_t <- (t - middle_value) / interval
  } else {
    middle_values <- sort(t)[c(n / 2, n / 2 + 1)]
    middle_value_avg <- mean(middle_values)
    half_interval <- interval / 2
    X_t <- (t - middle_value_avg) / half_interval
  }
  
  return(X_t)
}

#compute the Xt column
S.data$Xt <- compute_Xt(S.data$t)

#View results
S.data$Xt
```

After the transformation, the normal equations for the linear trend are:

$$
\sum Y_t = n \beta_0 + \beta_1 \sum X_t\\
\sum X_tY_t = \beta_0 \sum X_t + \beta_1 \sum X_t^2
$$

We use the normal equations to solve for $\beta_{0}$ and $\beta_{1}$, by solving them simultaneously. First we compute the necessary parameters $\sum Y_{t}$, $n$, $\sum X_{t}$, $\sum X_tY_t$ and $\sum X_t^2$, as follows:

```{r}
#compute parameters
Yt.sum <- sum(S.data$D.V)
n <- nrow(S.data)
Xt.sum <- sum(S.data$Xt)
XtYt.sum <- sum((S.data$Xt)*(S.data$D.V))
Xt.sq.sum <- sum((S.data$Xt)^2)

#view results
cat('\n Sum of Yt: ', Yt.sum,
    '\n n: ', n,
    '\n Sum of Xt: ', Xt.sum,
    '\n Sum of XtYt: ', XtYt.sum,
    '\n Sum of Xt squared: ', Xt.sq.sum)
```

Substituting these parameters into the normal equations gives us:

$$
349.2036 = 8\ \beta_{0} + 0\ \beta_{1}\\
156.9894 = 0\ \beta_{0} + 168\ \beta_{1}
$$

I used the matrix method to solve for $\beta_{0}$ and $\beta_{1}$, and thus rearranged the equations as follows:

$$
\begin{pmatrix}
8 & 0 \\
0 & 168
\end{pmatrix}
\begin{pmatrix}
\beta_0 \\
\beta_1
\end{pmatrix}
=
\begin{pmatrix}
349.2036 \\
156.9894
\end{pmatrix}
$$

I used the solve function to compute this as follows:

```{r}
# Define the coefficients matrix
A <- matrix(c(8, 0, 0, 168), nrow = 2, byrow = TRUE)

# Define the constants vector
b <- c(349.2036, 156.9894)

# Solve for beta
beta <- solve(A, b)

# Display the solutions
beta_0 <- beta[1]
beta_1 <- beta[2]

cat("beta_0 =", beta_0, "\n")
cat("beta_1 =", beta_1, "\n")
```

I then input my $\beta_{0}$ and $\beta_{1}$ values into the estimator function $\hat Y_t = \hat \beta_0 + \beta_1 X_{t}$, to get the linear equation:

$$
\hat Y_t = 43.6505 + 0.9345X_{t}
$$

I then transformed the estimator function to be in terms of t, by computing the **average of the two middle values** and **half of interval in t values** as per the formula:

$$
X_{t} = \frac{t - \text{average of two middle values}}{\text{half of interval in t values}}
$$

I computed these as follows:

```{r}
# Function to compute average of the middle values
compute_middle_value_avg <- function(t) {
  n <- length(t)
  
  if (n %% 2 == 1) {
    middle_value_avg <- median(t)
  } else {
    middle_values <- sort(t)[c(n / 2, n / 2 + 1)]
    middle_value_avg <- mean(middle_values)
  }
  
  return(middle_value_avg)
}

# Function to compute half the interval between the middle values
compute_half_interval <- function(t) {
  n <- length(t)
  interval <- diff(range(t)) / (n - 1)
  
  if (n %% 2 == 0) {
    half_interval <- interval / 2
  } else {
    half_interval <- NA
  }
  
  return(half_interval)
}

#compute parameters
mid <- compute_middle_value_avg(S.data$t)
interval <- compute_half_interval(S.data$t)

#view results
cat('\n Average of Middle Values: ', mid, '\n Half Interval of middle Values: ', interval)
```

Thus my $X_t$ function is:

$$
X_t = \frac{t-4.5}{0.5}
$$

I can hence re-write my final estimator as:

$$
\hat Y_t = 43.6505 + 0.9345(\frac{t-4.5}{0.5})
$$

I computed this for every row entry and added the results to their respective column, as follows:

```{r}
#compute estimated values
S.data$Yt.hat <- beta_0 + ((beta_1)*((S.data$t)-mid)/interval)

#View results
S.data$Yt.hat
```

## 3. Plot

**Plot the quarterly number of visitors for 2021 and 2022, along with the de-seasonalized values and trend values on the same graph.**

First, I combined the season and year columns of my data frame for better plotting, as follows:

```{r}
#combine the two columns
S.data$year_Season <- paste(S.data$year, S.data$Season, sep = "_")

#convert into factor variable
S.data$year_Season <- factor(S.data$year_Season, levels = S.data$year_Season)

#view results
S.data$year_Season
```

I then greated a **line graph** to compare the trends of the **Actual Values**, **Deseasonalised Values** and the **Linear Trend Line** as follows:

```{r}
#library(tidyverse)
# Plot original and forecasted values
ggplot(S.data, aes(x = year_Season)) +
 geom_line(aes(y = Value, color = "Actual Values", group = 1), linetype = "solid") +
  geom_point(aes(y = Value, color = "Actual Values", group = 1)) +
  geom_line(aes(y = D.V, color = "De-seasonalised Values", group = 1), linetype = "dashed") +
  geom_point(aes(y = D.V, color = "De-seasonalised Values", group = 1)) +
  geom_line(aes(y = Yt.hat, color = "Linear Trend", group = 1), linetype = "dashed") +
  geom_point(aes(y = Yt.hat, color = "Linear Trend", group = 1)) +
  labs(title = "Actual, Deseasonalised and Trend values",
       x = "Seasons",
       y = "# of Visitors (Thousands)",
       color = "Series") +
  scale_color_manual(values = c("Actual Values" = "black",
                                 "De-seasonalised Values" = "red",
                                 "Linear Trend" = "blue")) +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
